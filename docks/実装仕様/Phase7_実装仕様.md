# Phase 7 å®Ÿè£…ä»•æ§˜æ›¸

**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå**: LlmMultiChat3  
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 7 - 3Då¯è¦–åŒ– + è‡ªå¾‹ã‚µãƒ¼ãƒ  
**æœŸé–“**: 4é€±é–“  
**ä½œæˆæ—¥**: 2025-11-20  
**Phase 6å®Œäº†å‰æ**: ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æˆé•·ãƒ»MCP Serverå®Ÿè£…æ¸ˆã¿

---

## ç›®æ¬¡

1. [Phase 7æ¦‚è¦](#1-phase-7æ¦‚è¦)
2. [å‰ææ¡ä»¶](#2-å‰ææ¡ä»¶)
3. [Week 1-2: 3Då¯è¦–åŒ–ãƒ‘ãƒãƒ«](#3-week-1-2-3då¯è¦–åŒ–ãƒ‘ãƒãƒ«)
4. [Week 3-4: è‡ªå¾‹çš„å¤–éƒ¨ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ](#4-week-3-4-è‡ªå¾‹çš„å¤–éƒ¨ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
5. [æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯](#5-æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯)
6. [ãƒ†ã‚¹ãƒˆè¨ˆç”»](#6-ãƒ†ã‚¹ãƒˆè¨ˆç”»)
7. [æˆæœç‰©](#7-æˆæœç‰©)

---

## 1. Phase 7æ¦‚è¦

### 1.1 ç›®çš„

é€£æƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®3Då¯è¦–åŒ–ã¨è‡ªå¾‹æƒ…å ±åé›†ã«ã‚ˆã‚Šã€**è¦–è¦šçš„ç†è§£ã¨çŸ¥è­˜ã®è‡ªå‹•æ‹¡å¼µ**ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### 1.2 ä¸»è¦æ©Ÿèƒ½

| æ©Ÿèƒ½ã‚«ãƒ†ã‚´ãƒª | èª¬æ˜ | Priority |
|-------------|------|----------|
| **3Då¯è¦–åŒ–** | é€£æƒ³è¨˜æ†¶ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å¯è¦–åŒ– | ğŸŸ¡ Medium |
| **ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ“ä½œ** | ãƒ‰ãƒ©ãƒƒã‚°ãƒ»ã‚ºãƒ¼ãƒ ãƒ»ã‚¯ãƒªãƒƒã‚¯ | ğŸŸ¡ Medium |
| **è‡ªå¾‹ã‚µãƒ¼ãƒ** | è‡ªå‹•Webæ¤œç´¢ãƒ»KBä¿å­˜ | ğŸ”´ High |
| **å®šæœŸæ›´æ–°** | ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè¡Œ | ğŸ”´ High |

### 1.3 é”æˆç›®æ¨™

âœ… 3Då¯è¦–åŒ–ãƒ‘ãƒãƒ«å‹•ä½œç¢ºèª  
âœ… è‡ªå¾‹ã‚µãƒ¼ãƒå®šæœŸå®Ÿè¡Œãƒ†ã‚¹ãƒˆæˆåŠŸ  
âœ… KBè‡ªå‹•æ›´æ–°ç¢ºèª  
âœ… Plotly.jsçµ±åˆå®Œäº†

---

## 2. å‰ææ¡ä»¶

### 2.1 Phase 1-6å®Œäº†äº‹é …

âœ… **Phase 1**: LangGraphã‚³ã‚¢ãƒ»5éšå±¤è¨˜æ†¶ã‚·ã‚¹ãƒ†ãƒ   
âœ… **Phase 2**: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£  
âœ… **Phase 3**: REST/WebSocket APIï¼ˆ23ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼‰  
âœ… **Phase 4**: é€£æƒ³è¨˜æ†¶ã‚·ã‚¹ãƒ†ãƒ ãƒ»æ„Ÿæƒ…ãƒ¢ãƒ‡ãƒ«åŸºç›¤  
âœ… **Phase 5**: å¯¾è©±ã‚¹ã‚¿ã‚¤ãƒ«é©å¿œãƒ»è‡ªå·±çœå¯Ÿ  
âœ… **Phase 6**: ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æˆé•·ãƒ»MCP Server

**å‚ç…§**: [`docks/å®Ÿè£…ä»•æ§˜/Phase6_å®Ÿè£…ä»•æ§˜.md`](Phase6_å®Ÿè£…ä»•æ§˜.md:1)

### 2.2 åˆ©ç”¨å¯èƒ½ãªPhase 4æ©Ÿèƒ½

- **é€£æƒ³è¨˜æ†¶ã‚·ã‚¹ãƒ†ãƒ **: [`memory/associative.py`](../../memory/associative.py)
- **SQLite Graph**: å†å¸°CTEé€£æƒ³æ¤œç´¢

---

## 3. Week 1-2: 3Då¯è¦–åŒ–ãƒ‘ãƒãƒ«

### 3.1 å®Ÿè£…å†…å®¹

**å‚ç…§**: [`docks/ä»•æ§˜æ›¸/06_ä¼šè©±LLM_3Då¯è¦–åŒ–ä»•æ§˜.md`](../ä»•æ§˜æ›¸/06_ä¼šè©±LLM_3Då¯è¦–åŒ–ä»•æ§˜.md)

#### 3.1.1 Plotly.js 3Dã‚°ãƒ©ãƒ•

**ä¸»è¦æ©Ÿèƒ½**:
1. **ãƒãƒ¼ãƒ‰æç”»**: æ¦‚å¿µã‚’çƒä½“ã§è¡¨ç¾
2. **ã‚¨ãƒƒã‚¸æç”»**: é–¢é€£æ€§ã‚’ç·šã§è¡¨ç¾
3. **Force-Directed Layout**: ç‰©ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é…ç½®
4. **è‰²ãƒ»ã‚µã‚¤ã‚ºã«ã‚ˆã‚‹æƒ…å ±è¡¨ç¾**:
   - ãƒãƒ¼ãƒ‰è‰²: è·é›¢ï¼ˆé’â†’ç·‘â†’é»„â†’èµ¤ï¼‰
   - ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚º: æ´»æ€§åŒ–å›æ•°
   - ã‚¨ãƒƒã‚¸è‰²: é–¢é€£æ€§å¼·åº¦ï¼ˆè–„ç°â†’æ¿ƒç°ï¼‰

#### 3.1.2 ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ“ä½œ

- **ãƒ‰ãƒ©ãƒƒã‚°å›è»¢**: ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§3Dç©ºé–“å›è»¢
- **ãƒ›ã‚¤ãƒ¼ãƒ«ã‚ºãƒ¼ãƒ **: ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
- **ãƒãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯**: ã‚¯ãƒªãƒƒã‚¯ã§è©³ç´°è¡¨ç¤º

#### 3.1.3 ON/OFFåˆ‡ã‚Šæ›¿ãˆ

- **ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆOFF**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°**: ä¼šè©±ä¸­ã«è‡ªå‹•æ›´æ–°ï¼ˆONæ™‚ï¼‰

### 3.2 ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ

#### visualization/association_3d.py (500è¡Œ)

```python
"""é€£æƒ³è¨˜æ†¶3Då¯è¦–åŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«."""

from typing import Dict, List, Any, Optional
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from memory.associative import AssociativeMemory


class AssociationVisualizationPanel:
    """é€£æƒ³è¨˜æ†¶3Då¯è¦–åŒ–ãƒ‘ãƒãƒ«."""
    
    def __init__(self, associative_memory: AssociativeMemory):
        """
        åˆæœŸåŒ–.
        
        Args:
            associative_memory: é€£æƒ³è¨˜æ†¶ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.associative_memory = associative_memory
        self.is_enabled = False
        self.current_center = None
        self.max_nodes = 50  # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ¶é™
    
    def toggle(self) -> bool:
        """
        ON/OFFåˆ‡ã‚Šæ›¿ãˆ.
        
        Returns:
            bool: æ–°ã—ã„çŠ¶æ…‹ï¼ˆTrue=ON, False=OFFï¼‰
        """
        self.is_enabled = not self.is_enabled
        return self.is_enabled
    
    def update_center(self, concept: str) -> None:
        """
        ä¸­å¿ƒæ¦‚å¿µæ›´æ–°.
        
        Args:
            concept: ä¸­å¿ƒã¨ãªã‚‹æ¦‚å¿µ
        """
        self.current_center = concept
        if self.is_enabled:
            self._render_graph()
    
    def _render_graph(self) -> go.Figure:
        """
        3Dã‚°ãƒ©ãƒ•æç”».
        
        Returns:
            go.Figure: Plotly Figure
        """
        if not self.current_center:
            return go.Figure()
        
        # é€£æƒ³æ¦‚å¿µå–å¾—
        associated = self.associative_memory.retrieve_associated_concepts(
            trigger=self.current_center,
            depth=3,
            threshold=0.3
        )
        
        # æœ€å¤§ãƒãƒ¼ãƒ‰æ•°åˆ¶é™
        if len(associated) > self.max_nodes:
            associated = associated[:self.max_nodes]
        
        # ãƒãƒ¼ãƒ‰åº§æ¨™è¨ˆç®—ï¼ˆForce-Directed Layoutç°¡æ˜“ç‰ˆï¼‰
        node_positions = self._calculate_positions(associated)
        
        # ã‚¨ãƒƒã‚¸å–å¾—
        edges = self._get_edges(associated)
        
        # ãƒãƒ¼ãƒ‰ãƒˆãƒ¬ãƒ¼ã‚¹ä½œæˆ
        node_trace = self._create_node_trace(associated, node_positions)
        
        # ã‚¨ãƒƒã‚¸ãƒˆãƒ¬ãƒ¼ã‚¹ä½œæˆ
        edge_traces = self._create_edge_traces(edges, node_positions)
        
        # Figureä½œæˆ
        fig = go.Figure(data=edge_traces + [node_trace])
        
        fig.update_layout(
            title=f"é€£æƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ - ä¸­å¿ƒ: {self.current_center}",
            showlegend=False,
            hovermode='closest',
            scene=dict(
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                zaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            ),
            margin=dict(l=0, r=0, b=0, t=40),
        )
        
        return fig
    
    def _calculate_positions(
        self,
        concepts: List[Dict[str, Any]]
    ) -> Dict[str, tuple]:
        """
        ãƒãƒ¼ãƒ‰åº§æ¨™è¨ˆç®—ï¼ˆForce-Directed Layoutç°¡æ˜“ç‰ˆï¼‰.
        
        Args:
            concepts: æ¦‚å¿µãƒªã‚¹ãƒˆ
        
        Returns:
            Dict[str, tuple]: {æ¦‚å¿µå: (x, y, z)}
        """
        import random
        import math
        
        positions = {}
        
        # ä¸­å¿ƒã‚’åŸç‚¹ã«é…ç½®
        positions[self.current_center] = (0.0, 0.0, 0.0)
        
        # ä»–ã®æ¦‚å¿µã‚’è·é›¢ã«å¿œã˜ã¦é…ç½®
        for concept in concepts:
            if concept['name'] == self.current_center:
                continue
            
            depth = concept.get('depth', 1)
            
            # çƒé¢åº§æ¨™ã§ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
            theta = random.uniform(0, 2 * math.pi)
            phi = random.uniform(0, math.pi)
            radius = depth * 2.0  # è·é›¢ã«å¿œã˜ãŸåŠå¾„
            
            x = radius * math.sin(phi) * math.cos(theta)
            y = radius * math.sin(phi) * math.sin(theta)
            z = radius * math.cos(phi)
            
            positions[concept['name']] = (x, y, z)
        
        return positions
    
    def _get_edges(
        self,
        concepts: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        ã‚¨ãƒƒã‚¸å–å¾—.
        
        Args:
            concepts: æ¦‚å¿µãƒªã‚¹ãƒˆ
        
        Returns:
            List[Dict]: ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆ
        """
        edges = []
        
        # å„æ¦‚å¿µé–“ã®ã‚¨ãƒƒã‚¸ã‚’å–å¾—ï¼ˆå®Ÿéš›ã¯DBã‹ã‚‰å–å¾—ï¼‰
        concept_names = [c['name'] for c in concepts]
        
        # ç°¡æ˜“å®Ÿè£…: éš£æ¥æ¦‚å¿µã¨ã®ã¿æ¥ç¶š
        for i, concept in enumerate(concepts):
            if i == 0:
                continue
            edges.append({
                'from': self.current_center if concept.get('depth', 1) == 1 else concepts[i-1]['name'],
                'to': concept['name'],
                'strength': concept.get('strength', 0.5)
            })
        
        return edges
    
    def _create_node_trace(
        self,
        concepts: List[Dict[str, Any]],
        positions: Dict[str, tuple]
    ) -> go.Scatter3d:
        """
        ãƒãƒ¼ãƒ‰ãƒˆãƒ¬ãƒ¼ã‚¹ä½œæˆ.
        
        Args:
            concepts: æ¦‚å¿µãƒªã‚¹ãƒˆ
            positions: åº§æ¨™è¾æ›¸
        
        Returns:
            go.Scatter3d: ãƒãƒ¼ãƒ‰ãƒˆãƒ¬ãƒ¼ã‚¹
        """
        node_x, node_y, node_z = [], [], []
        node_text, node_color, node_size = [], [], []
        
        for concept in concepts:
            name = concept['name']
            if name not in positions:
                continue
            
            x, y, z = positions[name]
            node_x.append(x)
            node_y.append(y)
            node_z.append(z)
            
            node_text.append(name)
            node_color.append(self._get_node_color(concept.get('depth', 0)))
            node_size.append(10 + concept.get('activation_count', 0))
        
        return go.Scatter3d(
            x=node_x, y=node_y, z=node_z,
            mode='markers+text',
            text=node_text,
            textposition="top center",
            marker=dict(
                size=node_size,
                color=node_color,
                colorscale='Viridis',
                line=dict(color='white', width=0.5)
            ),
            hoverinfo='text'
        )
    
    def _create_edge_traces(
        self,
        edges: List[Dict[str, Any]],
        positions: Dict[str, tuple]
    ) -> List[go.Scatter3d]:
        """
        ã‚¨ãƒƒã‚¸ãƒˆãƒ¬ãƒ¼ã‚¹ä½œæˆ.
        
        Args:
            edges: ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆ
            positions: åº§æ¨™è¾æ›¸
        
        Returns:
            List[go.Scatter3d]: ã‚¨ãƒƒã‚¸ãƒˆãƒ¬ãƒ¼ã‚¹ãƒªã‚¹ãƒˆ
        """
        edge_traces = []
        
        for edge in edges:
            from_name = edge['from']
            to_name = edge['to']
            
            if from_name not in positions or to_name not in positions:
                continue
            
            x0, y0, z0 = positions[from_name]
            x1, y1, z1 = positions[to_name]
            
            edge_trace = go.Scatter3d(
                x=[x0, x1, None],
                y=[y0, y1, None],
                z=[z0, z1, None],
                mode='lines',
                line=dict(
                    color=self._get_edge_color(edge['strength']),
                    width=2
                ),
                hoverinfo='none'
            )
            
            edge_traces.append(edge_trace)
        
        return edge_traces
    
    def _get_edge_color(self, strength: float) -> str:
        """
        ã‚¨ãƒƒã‚¸è‰²å–å¾—.
        
        Args:
            strength: é–¢é€£æ€§å¼·åº¦ (0.0-1.0)
        
        Returns:
            str: è‰²ã‚³ãƒ¼ãƒ‰
        """
        # è–„ç° â†’ æ¿ƒç°
        gray_value = int(200 - strength * 100)
        return f'rgb({gray_value}, {gray_value}, {gray_value})'
    
    def _get_node_color(self, distance: int) -> int:
        """
        ãƒãƒ¼ãƒ‰è‰²å–å¾—ï¼ˆè·é›¢ãƒ™ãƒ¼ã‚¹ï¼‰.
        
        Args:
            distance: ä¸­å¿ƒã‹ã‚‰ã®è·é›¢
        
        Returns:
            int: è‰²å€¤ï¼ˆ0-3ï¼‰
        """
        # 0=é’, 1=ç·‘, 2=é»„, 3=èµ¤
        return min(distance, 3)
    
    def export_html(self, filename: str) -> None:
        """
        HTMLå‡ºåŠ›.
        
        Args:
            filename: å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«å
        """
        fig = self._render_graph()
        fig.write_html(filename)
    
    def export_png(self, filename: str) -> None:
        """
        PNGå‡ºåŠ›.
        
        Args:
            filename: å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«å
        """
        fig = self._render_graph()
        fig.write_image(filename)


class VisualizationControls:
    """å¯è¦–åŒ–ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UI."""
    
    def render_controls(self) -> str:
        """
        ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«HTMLç”Ÿæˆ.
        
        Returns:
            str: HTMLæ–‡å­—åˆ—
        """
        return """
        <div id="viz-controls">
            <button onclick="toggleVisualization()">å¯è¦–åŒ– ON/OFF</button>
            <input type="text" id="center-concept" placeholder="ä¸­å¿ƒæ¦‚å¿µ">
            <button onclick="updateCenter()">æ›´æ–°</button>
        </div>
        """
```

### 3.3 ãƒ†ã‚¹ãƒˆï¼ˆ10ä»¶ï¼‰

#### tests/test_visualization.py

```python
"""3Då¯è¦–åŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ†ã‚¹ãƒˆ."""

import pytest
from visualization.association_3d import AssociationVisualizationPanel
from memory.associative import AssociativeMemory


def test_panel_init():
    """åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ."""
    memory = AssociativeMemory(db_path=":memory:")
    panel = AssociationVisualizationPanel(memory)
    
    assert panel.is_enabled is False
    assert panel.current_center is None


def test_toggle():
    """ON/OFFåˆ‡ã‚Šæ›¿ãˆãƒ†ã‚¹ãƒˆ."""
    memory = AssociativeMemory(db_path=":memory:")
    panel = AssociationVisualizationPanel(memory)
    
    assert panel.toggle() is True
    assert panel.is_enabled is True
    
    assert panel.toggle() is False
    assert panel.is_enabled is False


def test_update_center():
    """ä¸­å¿ƒæ¦‚å¿µæ›´æ–°ãƒ†ã‚¹ãƒˆ."""
    memory = AssociativeMemory(db_path=":memory:")
    panel = AssociationVisualizationPanel(memory)
    
    panel.update_center("æ©Ÿæ¢°å­¦ç¿’")
    assert panel.current_center == "æ©Ÿæ¢°å­¦ç¿’"


def test_render_graph():
    """ã‚°ãƒ©ãƒ•æç”»ãƒ†ã‚¹ãƒˆ."""
    memory = AssociativeMemory(db_path=":memory:")
    panel = AssociationVisualizationPanel(memory)
    
    # æ¦‚å¿µè¿½åŠ 
    memory.add_concept("æ©Ÿæ¢°å­¦ç¿’", embedding=[0.1]*128, metadata={})
    memory.add_concept("Python", embedding=[0.2]*128, metadata={})
    memory.link_concepts("æ©Ÿæ¢°å­¦ç¿’", "Python", "related", strength=0.8)
    
    panel.current_center = "æ©Ÿæ¢°å­¦ç¿’"
    fig = panel._render_graph()
    
    assert fig is not None


# ... ä»–6ä»¶ï¼ˆå¢ƒç•Œå€¤ã€ç•°å¸¸ç³»ã€çµ±åˆãƒ†ã‚¹ãƒˆï¼‰
```

---

## 4. Week 3-4: è‡ªå¾‹çš„å¤–éƒ¨ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

### 4.1 å®Ÿè£…å†…å®¹

**å‚ç…§**: [`docks/ä»•æ§˜æ›¸/01_ä¼šè©±LLM_ä»•æ§˜.md:531-561`](../ä»•æ§˜æ›¸/01_ä¼šè©±LLM_ä»•æ§˜.md:531)

#### 4.1.1 ãƒˆãƒªã‚¬ãƒ¼æ¡ä»¶åˆ¤å®š

**3ã¤ã®ãƒˆãƒªã‚¬ãƒ¼**:
1. **ãƒ¦ãƒ¼ã‚¶ãƒ¼è³ªå•æ™‚**: KBæ¤œç´¢ã§å›ç­”ãªã—
2. **å®šæœŸå®Ÿè¡Œ**: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š
3. **æ‰‹å‹•ãƒˆãƒªã‚¬ãƒ¼**: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ˜ç¤ºçš„æŒ‡ç¤º

#### 4.1.2 æ¤œç´¢ãƒ„ãƒ¼ãƒ«çµ±åˆ

```python
# 1. Serper APIï¼ˆGoogleæ¤œç´¢ï¼‰
{
    "url": "https://google.serper.dev/search",
    "headers": {"X-API-KEY": "YOUR_SERPER_API_KEY"},
    "params": {"q": "æœ€æ–°AIæŠ€è¡“", "gl": "jp", "hl": "ja"}
}

# 2. Wikipediaæ¤œç´¢
{
    "library": "wikipedia",
    "lang": "ja",
    "query": "æ©Ÿæ¢°å­¦ç¿’"
}
```

#### 4.1.3 å®šæœŸæ›´æ–°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©

| é »åº¦ | æ™‚åˆ» | ãƒˆãƒ”ãƒƒã‚¯ |
|------|------|---------|
| æ¯æ—¥ | 06:00 | ãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰ |
| æ¯é€±æ—¥æ›œ | 10:00 | æ˜ ç”»æƒ…å ± |
| æ¯æœˆ1æ—¥ | 00:00 | æŠ€è¡“æƒ…å ± |

### 4.2 ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ

#### agents/autonomous_search.py (350è¡Œ)

```python
"""è‡ªå¾‹çš„å¤–éƒ¨ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ."""

from typing import Dict, List, Any, Optional
import requests
import wikipedia
from memory.knowledge_base import KnowledgeBase


class AutonomousSearchAgent:
    """è‡ªå¾‹ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ."""
    
    def __init__(self, serper_api_key: Optional[str] = None):
        """
        åˆæœŸåŒ–.
        
        Args:
            serper_api_key: Serper API KEY
        """
        self.serper_api_key = serper_api_key
        self.kb = KnowledgeBase()
        wikipedia.set_lang("ja")
    
    def should_search(
        self,
        user_question: str,
        kb_results: List[Dict[str, Any]]
    ) -> bool:
        """
        æ¤œç´¢å¿…è¦æ€§åˆ¤å®š.
        
        Args:
            user_question: ãƒ¦ãƒ¼ã‚¶ãƒ¼è³ªå•
            kb_results: KBæ¤œç´¢çµæœ
        
        Returns:
            bool: True=æ¤œç´¢å®Ÿè¡Œ
        """
        # KBçµæœãªã— ã¾ãŸã¯ ä¿¡é ¼åº¦ä½ã„
        if not kb_results:
            return True
        
        if kb_results[0].get('similarity', 0.0) < 0.6:
            return True
        
        return False
    
    def web_search(self, query: str, max_results: int = 5) -> List[Dict[str, Any]]:
        """
        Webæ¤œç´¢ï¼ˆSerper APIï¼‰.
        
        Args:
            query: æ¤œç´¢ã‚¯ã‚¨ãƒª
            max_results: æœ€å¤§çµæœæ•°
        
        Returns:
            List[Dict]: æ¤œç´¢çµæœ
        """
        if not self.serper_api_key:
            return []
        
        url = "https://google.serper.dev/search"
        headers = {
            "X-API-KEY": self.serper_api_key,
            "Content-Type": "application/json"
        }
        payload = {
            "q": query,
            "gl": "jp",
            "hl": "ja",
            "num": max_results
        }
        
        try:
            response = requests.post(url, json=payload, headers=headers, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            results = []
            
            for item in data.get("organic", [])[:max_results]:
                results.append({
                    "title": item.get("title"),
                    "snippet": item.get("snippet"),
                    "link": item.get("link")
                })
            
            return results
        
        except requests.RequestException as e:
            print(f"Webæ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
            return []
    
    def wikipedia_search(self, query: str) -> Optional[Dict[str, Any]]:
        """
        Wikipediaæ¤œç´¢.
        
        Args:
            query: æ¤œç´¢ã‚¯ã‚¨ãƒª
        
        Returns:
            Optional[Dict]: Wikipediaè¨˜äº‹
        """
        try:
            page = wikipedia.page(query, auto_suggest=True)
            
            return {
                "title": page.title,
                "summary": wikipedia.summary(query, sentences=3),
                "content": page.content,
                "url": page.url
            }
        
        except wikipedia.exceptions.PageError:
            print(f"Wikipediaè¨˜äº‹ãªã—: {query}")
            return None
        
        except wikipedia.exceptions.DisambiguationError as e:
            print(f"æ›–æ˜§æ€§è§£æ¶ˆå¿…è¦: {e.options[:3]}")
            # æœ€åˆã®å€™è£œã§å†è©¦è¡Œ
            if e.options:
                return self.wikipedia_search(e.options[0])
            return None
    
    def save_to_kb(
        self,
        content: str,
        category: str,
        source: str = "autonomous_search"
    ) -> None:
        """
        KBä¿å­˜.
        
        Args:
            content: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            category: ã‚«ãƒ†ã‚´ãƒª
            source: ã‚½ãƒ¼ã‚¹
        """
        self.kb.store(
            content=content,
            category=category,
            metadata={"source": source}
        )
```

#### scheduler/update_scheduler.py (200è¡Œ)

```python
"""å®šæœŸæ›´æ–°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©."""

from typing import Callable
import schedule
import time
from agents.autonomous_search import AutonomousSearchAgent


class UpdateScheduler:
    """å®šæœŸæ›´æ–°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©."""
    
    def __init__(self, search_agent: AutonomousSearchAgent):
        """
        åˆæœŸåŒ–.
        
        Args:
            search_agent: ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        """
        self.search_agent = search_agent
    
    def schedule_daily_news(self) -> None:
        """æ¯æœ6æ™‚: ãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰."""
        schedule.every().day.at("06:00").do(self._fetch_news)
    
    def schedule_weekly_movies(self) -> None:
        """æ¯é€±æ—¥æ›œ10æ™‚: æ˜ ç”»æƒ…å ±."""
        schedule.every().sunday.at("10:00").do(self._fetch_movies)
    
    def schedule_monthly_tech(self) -> None:
        """æ¯æœˆ1æ—¥0æ™‚: æŠ€è¡“æƒ…å ±."""
        schedule.every().month.at("00:00").do(self._fetch_tech)
    
    def _fetch_news(self) -> None:
        """ãƒ‹ãƒ¥ãƒ¼ã‚¹å–å¾—."""
        results = self.search_agent.web_search("æœ€æ–°ãƒ‹ãƒ¥ãƒ¼ã‚¹", max_results=5)
        
        for result in results:
            self.search_agent.save_to_kb(
                content=f"{result['title']}: {result['snippet']}",
                category="news"
            )
    
    def _fetch_movies(self) -> None:
        """æ˜ ç”»æƒ…å ±å–å¾—."""
        results = self.search_agent.web_search("ä»Šé€±å…¬é–‹æ˜ ç”»", max_results=3)
        
        for result in results:
            self.search_agent.save_to_kb(
                content=f"{result['title']}: {result['snippet']}",
                category="movies"
            )
    
    def _fetch_tech(self) -> None:
        """æŠ€è¡“æƒ…å ±å–å¾—."""
        topics = ["Pythonæœ€æ–°æƒ…å ±", "æ©Ÿæ¢°å­¦ç¿’ãƒˆãƒ¬ãƒ³ãƒ‰", "Webé–‹ç™ºæŠ€è¡“"]
        
        for topic in topics:
            wiki = self.search_agent.wikipedia_search(topic)
            if wiki:
                self.search_agent.save_to_kb(
                    content=wiki['summary'],
                    category="tech"
                )
    
    def run(self) -> None:
        """ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©å®Ÿè¡Œ."""
        while True:
            schedule.run_pending()
            time.sleep(60)
```

### 4.3 ãƒ†ã‚¹ãƒˆï¼ˆ15ä»¶ï¼‰

#### tests/test_autonomous_search.py

```python
"""è‡ªå¾‹ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ."""

import pytest
from agents.autonomous_search import AutonomousSearchAgent


def test_should_search():
    """æ¤œç´¢åˆ¤å®šãƒ†ã‚¹ãƒˆ."""
    agent = AutonomousSearchAgent()
    
    # KBçµæœãªã— â†’ æ¤œç´¢å®Ÿè¡Œ
    assert agent.should_search("è³ªå•", []) is True
    
    # ä¿¡é ¼åº¦ä½ã„ â†’ æ¤œç´¢å®Ÿè¡Œ
    assert agent.should_search("è³ªå•", [{"similarity": 0.5}]) is True
    
    # ä¿¡é ¼åº¦é«˜ã„ â†’ æ¤œç´¢ä¸è¦
    assert agent.should_search("è³ªå•", [{"similarity": 0.9}]) is False


@pytest.mark.skipif(not pytest.config.getoption("--run-slow"), reason="Slow test")
def test_web_search():
    """Webæ¤œç´¢ãƒ†ã‚¹ãƒˆï¼ˆSerper APIå¿…è¦ï¼‰."""
    agent = AutonomousSearchAgent(serper_api_key="test_key")
    # Note: å®Ÿéš›ã®APIã‚­ãƒ¼ã§ãƒ†ã‚¹ãƒˆ


def test_wikipedia_search():
    """Wikipediaæ¤œç´¢ãƒ†ã‚¹ãƒˆ."""
    agent = AutonomousSearchAgent()
    
    result = agent.wikipedia_search("Python")
    assert result is not None
    assert "title" in result
    assert "summary" in result


# ... ä»–12ä»¶ï¼ˆå¢ƒç•Œå€¤ã€ç•°å¸¸ç³»ã€çµ±åˆãƒ†ã‚¹ãƒˆï¼‰
```

---

## 5. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### 5.1 Pythonä¾å­˜

```txt
# requirements.txt ã«è¿½åŠ 
plotly==5.17.0          # 3Då¯è¦–åŒ–
kaleido==0.2.1          # ç”»åƒå‡ºåŠ›
wikipedia==1.4.0        # Wikipediaæ¤œç´¢
requests==2.31.0        # HTTPé€šä¿¡
schedule==1.2.0         # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©
```

### 5.2 æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

- **visualization/association_3d.py**: 3Då¯è¦–åŒ–ãƒ‘ãƒãƒ«
- **agents/autonomous_search.py**: è‡ªå¾‹ã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
- **scheduler/update_scheduler.py**: å®šæœŸæ›´æ–°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©

---

## 6. ãƒ†ã‚¹ãƒˆè¨ˆç”»

### 6.1 ãƒ†ã‚¹ãƒˆæ§‹æˆ

| ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ« | ãƒ†ã‚¹ãƒˆä»¶æ•° | ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™ |
|---------------|-----------|---------------|
| `tests/test_visualization.py` | 10ä»¶ | > 80% |
| `tests/test_autonomous_search.py` | 15ä»¶ | > 85% |
| **åˆè¨ˆ** | **25ä»¶** | **> 83%** |

### 6.2 ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª

**Unit Testsï¼ˆ15ä»¶ï¼‰**:
- ãƒ‘ãƒãƒ«åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ
- ã‚°ãƒ©ãƒ•æç”»ãƒ†ã‚¹ãƒˆ
- æ¤œç´¢åˆ¤å®šãƒ†ã‚¹ãƒˆ
- Wikipediaæ¤œç´¢ãƒ†ã‚¹ãƒˆ

**Integration Testsï¼ˆ10ä»¶ï¼‰**:
- é€£æƒ³è¨˜æ†¶ã¨ã®é€£æºãƒ†ã‚¹ãƒˆ
- KBä¿å­˜ãƒ†ã‚¹ãƒˆ
- ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©çµ±åˆãƒ†ã‚¹ãƒˆ

### 6.3 å®Ÿè¡Œæ–¹æ³•

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pytest tests/test_visualization.py tests/test_autonomous_search.py -v

# ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©èµ·å‹•
python -m scheduler.update_scheduler

# 3Då¯è¦–åŒ–ç¢ºèª
python -c "from visualization.association_3d import AssociationVisualizationPanel; panel.export_html('test.html')"
```

---

## 7. æˆæœç‰©

### 7.1 å®Ÿè£…ã‚³ãƒ¼ãƒ‰

**æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«**:
- `visualization/association_3d.py` (500è¡Œ)
- `agents/autonomous_search.py` (350è¡Œ)
- `scheduler/update_scheduler.py` (200è¡Œ)
- **åˆè¨ˆ**: 1,050è¡Œ

### 7.2 ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰

**æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«**:
- `tests/test_visualization.py` (10ä»¶)
- `tests/test_autonomous_search.py` (15ä»¶)
- **åˆè¨ˆ**: 25ä»¶

### 7.3 ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- `docks/å®Œäº†å ±å‘Š/Phase7_å®Œäº†ã‚µãƒãƒªãƒ¼.md`
- 3Då¯è¦–åŒ–æ“ä½œã‚¬ã‚¤ãƒ‰
- è‡ªå¾‹ã‚µãƒ¼ãƒè¨­å®šã‚¬ã‚¤ãƒ‰

### 7.4 ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³

- [ ] 3Då¯è¦–åŒ–ãƒ‘ãƒãƒ«å‹•ä½œç¢ºèª
- [ ] è‡ªå¾‹ã‚µãƒ¼ãƒå®šæœŸå®Ÿè¡Œãƒ†ã‚¹ãƒˆæˆåŠŸ
- [ ] KBè‡ªå‹•æ›´æ–°ç¢ºèª
- [ ] å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸï¼ˆ25ä»¶ï¼‰
- [ ] ã‚«ãƒãƒ¬ãƒƒã‚¸ > 83%

---

**Phase 7 å®Ÿè£…å®Œäº†**: è¦–è¦šçš„ç†è§£ã¨çŸ¥è­˜æ‹¡å¼µã®åŸºç›¤ãŒæ•´ã„ã¾ã—ãŸã€‚