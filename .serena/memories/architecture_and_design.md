# アーキテクチャと設計原則: LlmMultiChat3

## 🏗️ 全体アーキテクチャ

### レイヤー構成
```
ユーザー入力層
    ↓
入力処理・前処理層
    ↓
Router Node（コンテキスト認識・ルーティング）
    ↓
┌──────────────┬──────────────┐
│ Character Pool │ Tool Executor │
└──────────────┴──────────────┘
    ↓
LangGraph State Machine
    ↓
階層型記憶システム（5階層）
    ↓
出力処理・後処理層
    ↓
ユーザーへ出力
```

### 5階層記憶アーキテクチャ

| レイヤー | 技術スタック | TTL | 用途 |
|---------|-------------|-----|------|
| **短期記憶** | LangGraph State (RAM) | 6〜12ターン | 即時応答 |
| **中期記憶** | Redis → DuckDB | 24h〜30日 | セッション復帰 |
| **長期記憶** | VectorDB + PostgreSQL | 永続 | パーソナライズ |
| **連想記憶** | Neo4j Graph DB | 永続 | 創造的発想 |
| **知識ベース** | VectorDB(kb:*) | 定期更新 | RAG検索 |

## 🎨 設計原則

### 1. プラグイン型アーキテクチャ
- **動的ロード**: `personas/*.yaml` から自動読み込み
- **拡張可能**: 新しいLLM、ツール、知識ベースを動的に追加
- **疎結合**: モジュール間の依存を最小化

### 2. ハイブリッドLLM戦略
- **ローカル優先**: Ollama（Llama3-JP、Mistral等）
- **クラウド補完**: API（Claude、GPT、Gemini）
- **適応的選択**: タスクに応じて最適なLLMを自動選択

### 3. 人間らしい対話
- **感情モデル**: 8基本感情（喜び、信頼、恐れ、驚き、悲しみ、嫌悪、怒り、期待）
- **連想記憶**: Neo4jグラフDBによる概念ネットワーク
- **自己省察**: メタ認知による自律的改善
- **対話スタイル調整**: ユーザーに合わせた適応

### 4. マルチエージェント協調
- **役割分担**: ルミナ（司会）、クラリス（解説）、ノクス（検証）
- **並列処理**: LangGraphによる複数キャラ同時実行
- **状態共有**: 記憶層を通じた情報共有

## 🔧 技術スタック詳細

### コア技術
- **Python 3.10+**: メイン言語
- **LangGraph**: 状態遷移・フロー制御
- **LangChain**: 補助的ツール呼び出し
- **Ollama**: ローカルLLM実行

### 記憶・データベース
- **Redis**: 中期記憶キャッシュ（24h TTL）
- **DuckDB**: 中期記憶アーカイブ（7-30日）
- **VectorDB**: 長期記憶・知識ベース（Pinecone/Qdrant/ChromaDB）
- **PostgreSQL**: メタデータ・ユーザープロファイル
- **Neo4j**: 連想記憶グラフDB

### 外部連携
- **Serper API**: Web検索
- **Whisper API**: 音声→テキスト変換
- **VOICEVOX**: 日本語音声合成
- **各種LLM API**: OpenAI、Anthropic、Google AI

## 📐 設計パターン

### 1. State Pattern（状態パターン）
- LangGraph Stateで会話状態を管理
- 各ノードが状態を更新
- 条件分岐で次ノードを決定

### 2. Strategy Pattern（戦略パターン）
- キャラクター毎に異なる応答戦略
- ツール実行戦略の動的切替
- 記憶検索戦略の選択

### 3. Observer Pattern（観察者パターン）
- KPI変化を監視して成長トリガー
- 記憶更新イベントの購読
- ユーザーフィードバックの収集

### 4. Factory Pattern（ファクトリパターン）
- キャラクター動的生成
- ツール動的ロード
- プラグイン動的登録

## 🧠 記憶システム設計

### 記憶保存フロー
```python
# 短期→中期へのFlush
1. LangGraph State（6-12ターン保持）
2. 閾値到達時、要約生成
3. Redisへ保存（24h TTL）
4. 24h後、DuckDBへアーカイブ

# 中期→長期へのアーカイブ
1. DuckDBから7-30日経過データ抽出
2. VectorDBへembedding保存
3. PostgreSQLへメタデータ保存
4. S3/MinIOへバックアップ
```

### 記憶検索メカニズム
```python
# 3段階検索
1. 短期記憶（RAM）: O(1) 即時アクセス
2. 中期記憶（Redis）: O(1) キャッシュヒット
3. 長期記憶（VectorDB）: O(log n) ベクトル類似検索
```

### 連想記憶ネットワーク
```python
# Neo4jグラフDB構造
ノード: 概念、トピック、感情、人物、場所
エッジ: 関連性、強度、時間的近接性

# 連想検索アルゴリズム
1. トリガー概念からBFS/DFS探索
2. エッジ強度でパスをスコアリング
3. 上位K個の関連概念を返却
```

## 🎭 キャラクター設計

### ペルソナ定義（YAML）
```yaml
name: "ルミナ"
role: "司会・雑談・推論"
personality: "フレンドリー／洞察型"
model: "gpt-4o"
temperature: 0.8
tools: ["web_search", "image_generation"]
priority_kb: ["kb:movie", "kb:history"]
growth_enabled: true
emotional_model:
  baseline: {joy: 0.6, trust: 0.7}
  sensitivity: 0.8
```

### 成長システム
- **KPIベース**: ユーザー評価、タスク成功率
- **LoRAファインチューニング**: 会話パターン学習
- **レベルアップ**: `level = floor(sqrt(total_kpi / 10))`
- **衣装・口調変化**: レベル毎に視覚・言語表現が進化

## 🔒 セキュリティ設計

### 認証・認可
- **JWT**: Bearer Token認証
- **RBAC**: ロールベースアクセス制御
- **APIキー**: サービス間通信

### データ保護
- **暗号化**: TLS 1.3（通信）、AES-256（保存）
- **PII検出**: 個人情報自動マスキング
- **GDPR対応**: データポータビリティ、削除権

## 📈 スケーラビリティ

### 水平スケーリング
- **マルチプロセス**: Gunicorn/Uvicorn
- **ロードバランサ**: Nginx/HAProxy
- **セッション管理**: Redis共有セッション

### 垂直スケーリング
- **GPU活用**: ローカルLLM推論高速化
- **メモリ最適化**: ベクトルDB sharding
- **キャッシング**: Redis + CDN

## 🧪 テスト戦略

### テストレベル
1. **ユニットテスト**: pytest（各モジュール単体）
2. **統合テスト**: 記憶システム全体動作確認
3. **E2Eテスト**: ユーザーシナリオ再現
4. **負荷テスト**: Locust（1000同時接続）

### カバレッジ目標
- **Phase 1**: 仕様策定のため未実施
- **Phase 2**: 80%以上
- **Phase 3**: 90%以上

## 🌐 将来拡張（Phase 2-5）

### Phase 2: セキュリティ・品質
- エラーハンドリング強化
- ログ・モニタリング
- セキュリティ監査

### Phase 3: API・プラグイン
- REST/WebSocket API公開
- MCP対応
- プラグインエコシステム

### Phase 4: 国際化・音声
- 多言語対応（英語・中国語・韓国語）
- 音声入出力（Whisper + VOICEVOX）

### Phase 5: モバイル・画像
- PWA/React Nativeアプリ
- 画像生成・理解（Stable Diffusion + GPT-4V）

---

## 📚 参考ドキュメント
- [`docks/会話LLM_仕様.md`](docks/会話LLM_仕様.md) - 全機能詳細
- [`docks/会話LLM_実装仕様書.md`](docks/会話LLM_実装仕様書.md) - 実装ガイド
